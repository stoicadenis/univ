// test 1
int f(int x,float y){
		int r=max3(random()+0.5,x-1,7)*((x+y)*2-y/3);
L1		while(r){
			show(r);
			r=r-1;
			}
L2		return 0;	
}
max3(random()+0.5,x-1,7)*((x+y)*2-y/3);

random() i.f 0.5 + f.i x 1 - 7 max3() i.f x i.f y + 2 i.f * y 3 i.f / - *  


// Cadrul functie
call_dst	x	 y		ret_addr	old_FP	r	#	#	#	...
	-4		-3	 -2		-1				0	1	2	3	4


		ENTER		1+?		// 1 var locala +3 registri
		CALL		#2,random		// #2=random()
		CONV.i.f	#2,#2			// #2 = (float)#2
		ADD.f		#2,#2,0.5		// #2 = #2 + 0.5
		CONV.f.i	#2,#2			// #2 = (int)#2
		SUB.i		#3,#-3,1		// #3 = x - 1
		CALL		#2,max3,#2,#3,7	// #2=max3(#2,#3,7)
		CONV.i.f	#2,#2			// #2=(float)#2
		CONV.i.f	#3,#-3			// #3=(float)x
		ADD.f		#3,#3,#-2		// #3=#3+y
		CONV.i.f	#4,2			// #4=(float)2
		MUL.f		#3,#3,#4		// #3=#3*#4
		CONV.i.f	#4,3			// #4=(float)3
		DIV.f		#4,#-2,#4	  	// #4=y/#4
		SUB.f		#3,#3,#4
		MUL.f		#2,#2,#3		// #2=#2*#3
		CONV.f.i	#2,#2			// #2=(int)#2
		SET.i		#1,#2			// r=#2
L1:		JF			#1,L2
		CALL		#2,show,#1
		SUB.i		#1,#1,1			// r=r-1
		JMP			L1
L2:		RET.i

// test 11
float f(float x,float y,float z){
	float d=sqrt(x*x+y*y+z*z);
	if(d<10)return d/10+(x-y)/(z*3-1);
	return d/sqrt(x);
	}
	
// cadrul functiei
		call_dst	x	y	z	adr_ret	old_FP	d	#	#	#	#
			-5		-4	-3	-2	-1		0		1	2	3	4	5
		
		ENTER 5 // nr var locale + nr registri folositi
		MUL.f #2,#-4,#-4 // inmultire intre x*x
		MUL.f #3,#-3,#-3	// inmultire intre y*y
		MUL.f #4,#-2,#-2	// inmultire intre z*z
		ADD.f #2, #2, #3	adunare intre registri fol pt inmultire
		ADD.f #2, #2, #4
		CALL #2, sqrt, #2	// apelam functia sqrt si stocam in reg #2 rezultatul
		SET.f #1, #2	// setam in var locala d valoarea din reg #2
		STORE.i #2, 10
		CONV.i.f #2, #2	// convertim si stocam in reg #2 val 10 din int in float
		LESS.f #2, #1, #2	// verificam daca d < 10
		JF #2, L1	// daca e falsa verificarea atunci sarim la L1
		STORE.i #2, 10
		CONV.i.f #2, #2	// convertim si stocam in reg #2 val 10 din int in float
		DIV.f #2, #1, #2 // impartim si stocam in reg #2 rezultatul dintre d/10.0
		SUB.f #3, #-4, #-3	// scadem si stocam in reg #3 rezultatul x-y
		STORE.i #4, 3
		CONV.i.f #4, #4	// convertim si stocam in #4 val 3 => 3.0
		MUL.f #4, #-2, #4	// inmultim si stocam in #4 rezultatul z*3
		STORE.i #5, 1
		CONV.i.f #5, #5	// convertim si stocam in #5 val 1 => 1.0
		SUB.f #4, #4, #5	// scadem reg #4 si #5 adica z*3.0 - 1.0
		DIV.f #3, #3, #4	// impartim reg #3, #4 adica rez (x-y) / (z*3.0-1.0)
		ADD.f #2, #2, #3	// adunam reg #2 si #3 adica rez d/10 + (x-y)/(z*3-1)
		RET.f 3, #2	// returnam valoarea stocata in reg #2

L1:		CALL #2, sqrt, #-4 // apelam sqrt cu paramentru var x
		DIV.f #2, #1, #2	// impartim si stocam in #2 rez dintre d si #4
		RET.f 3, #2	// returnam valoarea din reg #2